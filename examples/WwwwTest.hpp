// Generated by the ProtoType compiler.  DO NOT EDIT!
// File:      WwwwTest.hpp
// Create on: Fri Dec 20 21:04:17 2013
//

#ifndef __WWWWTEST_HPP__
#define __WWWWTEST_HPP__

#include <stdint.h>
#include <string.h>
#include <vector>

namespace WwwwTest
{

class CType_stHdr
{
public:
    CType_stHdr();
    ~CType_stHdr();

    uint16_t& wLen();
    uint32_t& dwSeq();
    uint16_t& wCmd();
    size_t GetNumberOf_acReserved() const;
    uint8_t& acReserved(size_t uIndex);
    uint8_t* acReserved();
    void Assign_acReserved(const uint8_t acReserved[16]);
    const uint16_t& wCount() const;

    size_t SerializeToArray(void* pBuf, size_t uBufSize);
    size_t ParseFromArray(const void* pBuf, size_t uBufSize);

public:
    uint16_t m_wLen;
    uint32_t m_dwSeq;
    uint16_t m_wCmd;
    uint8_t m_acReserved[16];
    uint16_t m_wCount;
};

class CType_stBody
{
public:
    CType_stBody();
    ~CType_stBody();

    const uint16_t& wNameLen() const;
    size_t GetNumberOf_acName() const;
    uint8_t& acName(size_t uIndex);
    uint8_t* acName();
    void Assign_acName(const uint8_t acName[], size_t uNumberOfElements);
    uint8_t& Add_cName();
    const uint16_t& wPswLen() const;
    size_t GetNumberOf_acPsw() const;
    uint8_t& acPsw(size_t uIndex);
    uint8_t* acPsw();
    void Assign_acPsw(const uint8_t acPsw[], size_t uNumberOfElements);
    uint8_t& Add_cPsw();

    size_t SerializeToArray(void* pBuf, size_t uBufSize);
    size_t ParseFromArray(const void* pBuf, size_t uBufSize);

public:
    uint16_t m_wNameLen;
    std::vector<uint8_t> m_acName;
    uint16_t m_wPswLen;
    std::vector<uint8_t> m_acPsw;
};

class CType_stPack
{
public:
    CType_stPack();
    ~CType_stPack();

    uint8_t& cStx0x02();
    CType_stHdr& stHdr();
    size_t GetNumberOf_astBody() const;
    CType_stBody& astBody(size_t uIndex);
    CType_stBody* astBody();
    void Assign_astBody(const CType_stBody astBody[], size_t uNumberOfElements);
    CType_stBody& Add_stBody();
    uint8_t& cEtx0x03();

    size_t SerializeToArray(void* pBuf, size_t uBufSize);
    size_t ParseFromArray(const void* pBuf, size_t uBufSize);

public:
    uint8_t m_cStx0x02;
    CType_stHdr m_stHdr;
    std::vector<CType_stBody> m_astBody;
    uint8_t m_cEtx0x03;
};

};



///////////////// - Inline Implementation - /////////////////

namespace WwwwTest
{

#ifndef ___constant_swab64
#define ___constant_swab64(x) \
    ((uint64_t)( \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) | \
    (uint64_t)(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56) ))
#endif // ___constant_swab64

inline uint64_t htonl64(uint64_t host)
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    return ___constant_swab64(host);
#else
    return host;
#endif
}

inline uint64_t ntohl64(uint64_t net)
{
#if __BYTE_ORDER == __LITTLE_ENDIAN
    return ___constant_swab64(net);
#else
    return host;
#endif
}

inline CType_stHdr::CType_stHdr()
: m_wLen(uint16_t()), m_dwSeq(uint32_t()), m_wCmd(uint16_t()), m_wCount(uint16_t())
{
    memset(m_acReserved, 0, sizeof(m_acReserved));
}

inline CType_stHdr::~CType_stHdr()
{
}

inline uint16_t& CType_stHdr::wLen()
{
    return m_wLen;
}

inline uint32_t& CType_stHdr::dwSeq()
{
    return m_dwSeq;
}

inline uint16_t& CType_stHdr::wCmd()
{
    return m_wCmd;
}

inline size_t CType_stHdr::GetNumberOf_acReserved() const
{
    return 16;
}

inline uint8_t& CType_stHdr::acReserved(size_t uIndex)
{
    assert(uIndex < GetNumberOf_acReserved());
    return m_acReserved[uIndex];
}

inline uint8_t* CType_stHdr::acReserved()
{
    return &m_acReserved[0];
}

inline void CType_stHdr::Assign_acReserved(const uint8_t acReserved[16])
{
    memcpy(m_acReserved, acReserved, sizeof(m_acReserved));
}

inline const uint16_t& CType_stHdr::wCount() const
{
    return m_wCount;
}

inline size_t CType_stHdr::SerializeToArray(void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    char* pPos = (char*)pBuf + uSize;

    *(uint16_t*)pPos = htons(m_wLen);
    pPos += sizeof(m_wLen);

    *(uint32_t*)pPos = htonl(m_dwSeq);
    pPos += sizeof(m_dwSeq);

    *(uint16_t*)pPos = htons(m_wCmd);
    pPos += sizeof(m_wCmd);

    uSize = GetNumberOf_acReserved() * sizeof(uint8_t);
    memcpy(pPos, &m_acReserved[0], uSize);
    pPos += uSize;

    *(uint16_t*)pPos = htons(m_wCount);
    pPos += sizeof(m_wCount);

    return (size_t)pPos - (size_t)pBuf;
}

inline size_t CType_stHdr::ParseFromArray(const void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    const char* pPos = (const char*)pBuf + uSize;

    m_wLen = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wLen);

    m_dwSeq = ntohl(*(uint32_t*)pPos);
    pPos += sizeof(m_dwSeq);

    m_wCmd = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wCmd);

    uSize = GetNumberOf_acReserved() * sizeof(uint8_t);
    memcpy(&m_acReserved[0], pPos, uSize);
    pPos += uSize;

    m_wCount = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wCount);

    return (size_t)pPos - (size_t)pBuf;
}

inline CType_stBody::CType_stBody()
: m_wNameLen(uint16_t()), m_wPswLen(uint16_t())
{
}

inline CType_stBody::~CType_stBody()
{
}

inline const uint16_t& CType_stBody::wNameLen() const
{
    return m_wNameLen;
}

inline size_t CType_stBody::GetNumberOf_acName() const
{
    return m_acName.size();
}

inline uint8_t& CType_stBody::acName(size_t uIndex)
{
    assert(uIndex < GetNumberOf_acName());
    return m_acName[uIndex];
}

inline uint8_t* CType_stBody::acName()
{
    return &m_acName[0];
}

inline void CType_stBody::Assign_acName(const uint8_t acName[], size_t uNumberOfElements)
{
    m_acName.resize(uNumberOfElements);
    m_wNameLen = m_acName.size();
    memcpy(&m_acName[0], acName, uNumberOfElements * sizeof(uint8_t));
}

inline uint8_t& CType_stBody::Add_cName()
{
    m_acName.push_back(uint8_t());
    m_wNameLen = m_acName.size();
    return m_acName.back();
}

inline const uint16_t& CType_stBody::wPswLen() const
{
    return m_wPswLen;
}

inline size_t CType_stBody::GetNumberOf_acPsw() const
{
    return m_acPsw.size();
}

inline uint8_t& CType_stBody::acPsw(size_t uIndex)
{
    assert(uIndex < GetNumberOf_acPsw());
    return m_acPsw[uIndex];
}

inline uint8_t* CType_stBody::acPsw()
{
    return &m_acPsw[0];
}

inline void CType_stBody::Assign_acPsw(const uint8_t acPsw[], size_t uNumberOfElements)
{
    m_acPsw.resize(uNumberOfElements);
    m_wPswLen = m_acPsw.size();
    memcpy(&m_acPsw[0], acPsw, uNumberOfElements * sizeof(uint8_t));
}

inline uint8_t& CType_stBody::Add_cPsw()
{
    m_acPsw.push_back(uint8_t());
    m_wPswLen = m_acPsw.size();
    return m_acPsw.back();
}

inline size_t CType_stBody::SerializeToArray(void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    char* pPos = (char*)pBuf + uSize;

    *(uint16_t*)pPos = htons(m_wNameLen);
    pPos += sizeof(m_wNameLen);

    uSize = GetNumberOf_acName() * sizeof(uint8_t);
    memcpy(pPos, &m_acName[0], uSize);
    pPos += uSize;

    *(uint16_t*)pPos = htons(m_wPswLen);
    pPos += sizeof(m_wPswLen);

    uSize = GetNumberOf_acPsw() * sizeof(uint8_t);
    memcpy(pPos, &m_acPsw[0], uSize);
    pPos += uSize;

    return (size_t)pPos - (size_t)pBuf;
}

inline size_t CType_stBody::ParseFromArray(const void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    const char* pPos = (const char*)pBuf + uSize;

    m_wNameLen = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wNameLen);

    m_acName.resize(m_wNameLen);
    uSize = GetNumberOf_acName() * sizeof(uint8_t);
    memcpy(&m_acName[0], pPos, uSize);
    pPos += uSize;

    m_wPswLen = ntohs(*(uint16_t*)pPos);
    pPos += sizeof(m_wPswLen);

    m_acPsw.resize(m_wPswLen);
    uSize = GetNumberOf_acPsw() * sizeof(uint8_t);
    memcpy(&m_acPsw[0], pPos, uSize);
    pPos += uSize;

    return (size_t)pPos - (size_t)pBuf;
}

inline CType_stPack::CType_stPack()
: m_cStx0x02(uint8_t()), m_cEtx0x03(uint8_t())
{
}

inline CType_stPack::~CType_stPack()
{
}

inline uint8_t& CType_stPack::cStx0x02()
{
    return m_cStx0x02;
}

inline CType_stHdr& CType_stPack::stHdr()
{
    return m_stHdr;
}

inline size_t CType_stPack::GetNumberOf_astBody() const
{
    return m_astBody.size();
}

inline CType_stBody& CType_stPack::astBody(size_t uIndex)
{
    assert(uIndex < GetNumberOf_astBody());
    return m_astBody[uIndex];
}

inline CType_stBody* CType_stPack::astBody()
{
    return &m_astBody[0];
}

inline void CType_stPack::Assign_astBody(const CType_stBody astBody[], size_t uNumberOfElements)
{
    m_astBody.resize(uNumberOfElements);
    m_stHdr.m_wCount = m_astBody.size();
    for (size_t i = 0; i < uNumberOfElements; ++i) 
    {
        m_astBody[i] = astBody[i];
    }
}

inline CType_stBody& CType_stPack::Add_stBody()
{
    m_astBody.push_back(CType_stBody());
    m_stHdr.m_wCount = m_astBody.size();
    return m_astBody.back();
}

inline uint8_t& CType_stPack::cEtx0x03()
{
    return m_cEtx0x03;
}

inline size_t CType_stPack::SerializeToArray(void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    char* pPos = (char*)pBuf + uSize;

    *(uint8_t*)pPos = m_cStx0x02;
    pPos += sizeof(m_cStx0x02);

    uSize = m_stHdr.SerializeToArray(pPos, uBufSize - (size_t)pPos + (size_t)pBuf);
    pPos += uSize;

    for (size_t i = 0; i < GetNumberOf_astBody(); ++i)
    {
        uSize = m_astBody[i].SerializeToArray(pPos, uBufSize - (size_t)pPos + (size_t)pBuf);
        pPos += uSize;
    }

    *(uint8_t*)pPos = m_cEtx0x03;
    pPos += sizeof(m_cEtx0x03);

    return (size_t)pPos - (size_t)pBuf;
}

inline size_t CType_stPack::ParseFromArray(const void* pBuf, size_t uBufSize)
{
    size_t uSize = 0;
    const char* pPos = (const char*)pBuf + uSize;

    m_cStx0x02 = *(uint8_t*)pPos;
    pPos += sizeof(m_cStx0x02);

    uSize = m_stHdr.ParseFromArray(pPos, uBufSize - (size_t)pPos + (size_t)pBuf);
    pPos += uSize;

    m_astBody.resize(m_stHdr.m_wCount);
    for (size_t i = 0; i < m_astBody.size(); ++i)
    {
        uSize = m_astBody[i].ParseFromArray(pPos, uBufSize - (size_t)pPos + (size_t)pBuf);
        pPos += uSize;
    }

    m_cEtx0x03 = *(uint8_t*)pPos;
    pPos += sizeof(m_cEtx0x03);

    return (size_t)pPos - (size_t)pBuf;
}

};

#endif  //  __WWWWTEST_HPP__
